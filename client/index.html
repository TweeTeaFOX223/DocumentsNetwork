<!DOCTYPE html>
<?xml version="1.0" encoding="UTF-8"?>

<html lang="ja">
<!-- ==== Begin Header ==== -->
    <head>
        <meta charset="UTF-8">
        <title>k-saito-brousing</title>
        <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.3/dist/jquery.min.js"></script>
        <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/fomantic-ui@2.9.2/dist/semantic.min.css">
<!-- ==== Begin Style ==== -->
        <style>
            .container-svg {
                width : 1700px;
                height: 800px;
                margin: 20px 0px 0px 0px;
            }
            .circle {
                opacity: 1;
                cursor: pointer;
            }
            .category {
                font-size: 24px;
            }
            .ribbon-setting {
                cursor: default !important;
            }
        </style>
<!-- ==== End Style ==== -->
    </head>
<!-- ==== End Header ==== -->

<!-- ==== Begin Body ==== -->
    <body>
<!-- ==== Begin Box ==== -->
        <main>

            <!-- loading icon -->
            <section id="box-loader"></section>

            <!-- loaded document -->
            <section id="box-loaded-document"></section>

            <!-- document form -->
            <section id="box-form"></section>

            <!-- margin -->
            <section id="box-divider-1"></section>

            <!-- categories -->
            <section id="box-category"></section>

            <!-- network -->
            <section id="box-network"></section>

            <!-- margin -->
            <section id="box-divider-2"></section>

            <!-- document details -->
            <section id="box-document-detail"></section>

        </main>
<!-- ==== End Box ==== -->

<!-- ==== Begin Template ==== -->
        <!-- mapping box-loader -->
        <template id="template-loader">
            <div class="ui hidden divider"></div>
            <div class="ui large active teal text loader">Generating Network</div>
        </template>

        <!-- mapping loaded document -->
        <template id="template-loaded-document">
            <div id="template-query-document" class="ui container raised segment">
                <a class="ui red ribbon label ribbon-setting">
                    <!-- Insert query document name -->
                </a>
                <div class="ui hidden divider"></div>
                <p>
                    <!-- Insert query document context -->
                </p>
            </div>
        </template>

        <!-- mapping box-form -->
        <template id="template-form">
            <form class="ui form" onsubmit="handleFormSubmit(event)">
                <div class="field">
                    <input type="file" id="template-invisible-upload" class="ui invisible file input">
                    <label for="template-invisible-upload" class="ui olive icon button">
                        <i class="file icon"></i>
                        Upload query document
                    </label>
                </div>
                <button class="ui primary button" type="submit">Submit</button>
            </form>
        </template>

        <!-- mapping box-divider -->
        <template id="template-divider">
            <div class="ui large hidden divider"></div>
            <h4 id="divider-header" class="ui massive horizontal divider header">
                <i class=""></i>
                <!-- Insert text -->
            </h4>
            <div class="ui large hidden divider"></div>
        </template>

        <!-- mapping box-categories -->
        <template id="template-category">
            <div class="ui label">
                <i class="circle icon" style="visibility: visible;"></i>
                <!-- Insert category name -->
            </div>
        </template>

        <!-- mapping box-network -->
        <template id="template-network">
            <svg
                xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                class="container-svg"
            >
            </svg>
        </template>

        <!-- mapping box-document-detail -->
        <template id="template-document-detail">
            <div class="ui two column doubling stackable grid container">
                <div id="template-query-column" class="column">
                    <div id="template-query-document" class="ui raised segment">
                        <a class="ui red ribbon label ribbon-setting">
                            <!-- Insert query document name -->
                        </a>
                        <div class="ui hidden divider"></div>
                        <p>
                            <!-- Insert query document context -->
                        </p>
                    </div>
                </div>
                <div id="template-similar-column" class="column">
                    <div id="template-similar-document" class="ui segment">
                        <a class="ui orange ribbon label ribbon-setting">
                            <!-- Insert similar document name -->
                        </a>
                        <div class="ui hidden divider"></div>
                        <p>
                            <!-- Insert similar document context -->
                        </p>
                    </div>
                </div>
            </div>
        </template>
<!-- ==== End Template ==== -->

<!-- ==== Begin Script ==== -->
        <script>

            // カテゴリーデータ・文書データ
            let   categories = [];
            const documents  = [];

            // ボックス id
            const boxLoaderId         = "#box-loader";
            const boxLoadedDocumentId = "#box-loaded-document";
            const boxDivider1Id       = "#box-divider-1";
            const boxDivider2Id       = "#box-divider-2";
            const boxFormId           = "#box-form";
            const boxCategoryId       = "#box-category";
            const boxNetworkId        = "#box-network";
            const boxDocumentDetailId = "#box-document-detail";

            // テンプレート id
            const templateLoaderId         = "#template-loader";
            const templateLoadedDocumentId = "#template-loaded-document";
            const templateDividerId        = "#template-divider";
            const templateFormId           = "#template-form";
            const templateCategoryId       = "#template-category";
            const templateNetworkId        = "#template-network";
            const templateDocumentDetailId = "#template-document-detail";

            /* KNNデータの取得関数 */
            async function getKkData(uploadDocument)
            {
                // バックエンド側のパス
                const pathKkData = "http://localhost/cgi-bin/main.cgi";

                try {
                    const response = await fetch(pathKkData, {
                        method : "POST",
                        mode   : "cors",
                        headers: { "Content-Type": "text/plain" },
                        body   : `{\"name\":\"${uploadDocument.name}\",\"normalText\":\"${uploadDocument.normalText}\",\"wakachiText\":\"${uploadDocument.wakachiText}\"}`,
                    })
                    .then(response => response.json())
                    .then(data => {
                        generateNetwork(data); // ネットワーク図を生成
                    })
                }
                catch (error) {
                    console.error('Fetch error:', error);
                }
            }

            /* ネットワーク図の生成関数 */
            function generateNetwork(knnDatas)
            {
                generateEdges(knnDatas.edges);
                generateNodes(knnDatas.nodes);
                generateCategories(knnDatas.nodes); // ノードの要素にカテゴリー情報が存在する
            }

            /* クエリ文書の内容を DOM に挿入するメソッド */
            const generateQueryDocumentDetail = (docTitle, docText) =>
            {
                // ブロック id
                const templateQueryColumn     = "#template-query-column";
                const templateQueryDocumentId = "#template-query-document";

                // タイトルと内容を挿入するテンプレートを参照
                const templateDocumentDetail = document.querySelector(templateDocumentDetailId);
                const templateQueryDocument  = templateDocumentDetail.content.querySelector(templateQueryDocumentId);
                
                // 複製を生成
                const cloneDocumentDetail = document.importNode(templateDocumentDetail.content, true);
                const cloneQueryDocument  = document.importNode(templateQueryDocument, true);

                // 文書内容を設定
                cloneQueryDocument.querySelector("a").innerHTML = docTitle;
                cloneQueryDocument.querySelector("p").innerHTML = docText;
                cloneDocumentDetail.querySelector(templateQueryColumn).innerHTML = '';
                cloneDocumentDetail.querySelector(templateQueryColumn).appendChild(cloneQueryDocument);

                // ボックスに挿入
                const boxDocumentDetail = document.querySelector(boxDocumentDetailId);
                boxDocumentDetail.innerHTML = '';
                boxDocumentDetail.appendChild(cloneDocumentDetail);
            }

            /* 類似文書の内容を DOM に挿入するメソッド */
            const generateSimilarDocumentDetail = (docName) =>
            {
                // ブロック id
                const templateSimilarColumn     = "#template-similar-column";
                const templateSimilarDocumentId = "#template-similar-document";

                // タイトルと内容を挿入するテンプレートを参照
                const templateDocumentDetail  = document.querySelector(templateDocumentDetailId).content.cloneNode(true);
                const templateSimilarDocument = templateDocumentDetail.querySelector(templateSimilarDocumentId);
                
                // 複製を生成
                const cloneSimilarDocument = document.importNode(templateSimilarDocument, true);

                // 文書データを取得
                const targetDoc = documents.find((doc) => doc.name === docName);

                // 文書内容を設定
                cloneSimilarDocument.querySelector("a").innerHTML = `${targetDoc.keyword} ${targetDoc.category} ${targetDoc.name}`;
                cloneSimilarDocument.querySelector("p").innerHTML = targetDoc.text;

                // ボックスに挿入
                const boxDocumentDetail = document.querySelector(boxDocumentDetailId);
                boxDocumentDetail.querySelector(templateSimilarColumn).innerHTML = '';
                boxDocumentDetail.querySelector(templateSimilarColumn).appendChild(cloneSimilarDocument);
            }

            /* エッジの生成関数 */
            function generateEdges(attributesEdges)
            {
                // ネットワーク図を初期化
                const boxNetwork = document.querySelector(boxNetworkId);
                boxNetwork.innerHTML = '';

                // svg のテンプレートを参照
                const templateNetwork = document.querySelector(templateNetworkId);
                const templateSVG = templateNetwork.content.querySelector("svg");
                const cloneSVG = document.importNode(templateSVG, true);

                // エッジを追加するメソッド
                const addEdge = (attributeEdge) =>
                {
                    // <line> を生成して属性を設定
                    const edge = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    edge.setAttribute("x1", attributeEdge.x1);
                    edge.setAttribute("y1", attributeEdge.y1);
                    edge.setAttribute("x2", attributeEdge.x2);
                    edge.setAttribute("y2", attributeEdge.y2);
                    edge.setAttribute("stroke", "#999999");
                    edge.setAttribute("stroke-opacity", "1");
                    edge.setAttribute("stroke-width", "2");

                    // ボックスの子要素に <line> を追加
                    cloneSVG.appendChild(edge);
                };

                // ボックスにエッジを追加
                attributesEdges.forEach(attributeEdge =>
                {
                    addEdge(attributeEdge);
                });

                boxNetwork.appendChild(cloneSVG);
            }

            /* ノードの生成関数 */
            function generateNodes(attributeNodes)
            {
                // エッジが描画された svg を参照
                const boxNetwork = document.querySelector(boxNetworkId);
                const boxSVG     = boxNetwork.querySelector("svg");

                // ノードを追加するメソッド
                const addNode = (attributeNode) =>
                {
                    // 文書概要
                    const docName    = attributeNode.fileName;
                    const docKeyword = attributeNode.keyword;
                    const docId      = attributeNode.id;
                    const docText    = attributeNode.title;
                    const docColor   = attributeNode.color;
                    const docTitle   = `${docKeyword} ${docId} ${docName}`;

                    // カテゴリーデータに追加
                    categories.push({
                        keyword: docKeyword,
                        color  : docColor
                    });

                    // 文書データに追加
                    documents.push({
                        name    : docName,
                        keyword : docKeyword,
                        category: docId,
                        text    : docText
                    });

                    // <a> タグを複製して属性を追加
                    const node = document.createElementNS("http://www.w3.org/2000/svg", "a");
                    node.setAttribute("href", "");

                    // <circle> タグを複製して属性を追加
                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", attributeNode.cx);
                    circle.setAttribute("cy", attributeNode.cy);
                    circle.setAttribute("r", attributeNode.r);
                    circle.setAttribute("fill", docColor);
                    circle.setAttribute("onclick", `generateSimilarDocumentDetail("${docName}")`);
                    circle.classList.add("circle");

                    // <title> タグを作成してツールチップ用のテキストを設定
                    const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
                    title.textContent = `${docTitle} ${docText}`;

                    // <circle> の子要素に <title> を挿入
                    circle.appendChild(title);

                    // <a> の子要素に <circle> を挿入
                    node.appendChild(circle);

                    // ボックスの子要素に <a> を追加
                    boxSVG.appendChild(circle);
                };

                // 文書詳細画面にクエリ文書を追加
                generateQueryDocumentDetail(
                    `${attributeNodes[0].keyword} ${attributeNodes[0].id} ${attributeNodes[0].fileName}`,
                    attributeNodes[0].title
                );

                // ボックスにノードを追加
                attributeNodes.forEach(attributeNode => {
                    addNode(attributeNode);
                });
            }

            /* カテゴリーの生成関数 */
            function generateCategories(attributeCategories)
            {
                const boxCategory      = document.querySelector(boxCategoryId);
                const templateCategory = document.querySelector(templateCategoryId);

                // カテゴリーを追加するメソッド
                const addCategory = (category) =>
                {
                    // カテゴリー DOM を複製
                    const cloneCategory = document.importNode(templateCategory.content, true);

                    // 「カテゴリー名,総数,カテゴリー色」を設定
                    cloneCategory.querySelector("div").childNodes[2].textContent = `${category.keyword}:${category.total}`;
                    cloneCategory.querySelector("i").style.color = category.color;
                    
                    // 設定後のカテゴリー DOM をボックスに挿入
                    boxCategory.appendChild(cloneCategory);
                }

                // カテゴリーデータの重複を削除
                const categories = Array.from(new Set(attributeCategories.map((attributeCategory) => attributeCategory.keyword)))
                                        .map((keyword) => {
                                            const duplicatedCategories = attributeCategories.filter((attributeCategory) => attributeCategory.keyword === keyword);
                                            const category = duplicatedCategories[0];
                                            return {
                                                keyword: category.keyword,
                                                total: Number(duplicatedCategories.length),
                                                color: category.color
                                            };})
                                        .filter(category => category.total >= 3); // totalが5以上の要素のみ残す

                // ボックスに降順ソートしたカテゴリーを追加
                categories.sort((a, b) => {return Number(b.total) - Number(a.total)});
                categories.forEach(category => {
                    addCategory(category);
                });
            }

            /* 境界線の生成関数 */
            function generateDivider()
            {
                const templateDivider = document.querySelector(templateDividerId);
                const cloneDivider1   = document.importNode(templateDivider.content, true);
                const cloneDivider2   = document.importNode(templateDivider.content, true);
                const boxDivider1     = document.querySelector(boxDivider1Id);
                const boxDivider2     = document.querySelector(boxDivider2Id);
                boxDivider1.appendChild(cloneDivider1);
                boxDivider2.appendChild(cloneDivider2);
                boxDivider1.querySelector("i").classList.add("connectdevelop", "icon");
                boxDivider2.querySelector("i").classList.add("file", "alternate", "outline", "icon");
                boxDivider1.querySelector("#divider-header").childNodes[2].textContent = "Network";
                boxDivider2.querySelector("#divider-header").childNodes[2].textContent = "Description";
            }

            /* フォームの生成関数 */
            function generateDocumentForm()
            {
                const templateForm = document.querySelector(templateFormId);
                const cloneForm    = document.importNode(templateForm.content, true);
                const boxForm      = document.querySelector(boxFormId);
                boxForm.innerHTML  = '';
                boxForm.appendChild(cloneForm);
            }

            /* クエリ文書ロード画面の生成関数 */
            function generateLoadedDocument(uploadedName, uploadedText)
            {
                const boxLoadedDocument      = document.querySelector(boxLoadedDocumentId);
                const templateLoadedDocument = document.querySelector(templateLoadedDocumentId);
                const cloneLoadedDocument    = document.importNode(templateLoadedDocument.content, true);

                // 文書内容を設定
                cloneLoadedDocument.querySelector("a").innerHTML = uploadedName;
                cloneLoadedDocument.querySelector("p").innerHTML = uploadedText;

                // ボックスに挿入
                boxLoadedDocument.innerHTML = '';
                boxLoadedDocument.appendChild(cloneLoadedDocument);
            }

            /* ローダーの生成関数 */
            function generateLoader()
            {
                // ローダーを複製
                const boxLoader      = document.querySelector(boxLoaderId);
                const templateLoader = document.querySelector(templateLoaderId);
                const cloneLoader    = document.importNode(templateLoader.content, true);

                // 描画しているカテゴリー・ネットワーク・文書詳細画面・フォームを削除
                const boxCategory           = document.querySelector(boxCategoryId);
                const boxNetwork            = document.querySelector(boxNetworkId);
                const boxDocumentDetail     = document.querySelector(boxDocumentDetailId);
                const boxForm               = document.querySelector(boxFormId);
                boxCategory.innerHTML       = '';
                boxNetwork.innerHTML        = '';
                boxDocumentDetail.innerHTML = '';
                boxForm.innerHTML           = '';

                // ローダーを追加
                boxLoader.appendChild(cloneLoader);
            }

            /* ローダーの削除関数 */
            function clearLoader()
            {
                // ローダーを削除
                const boxLoader             = document.querySelector(boxLoaderId);
                const boxLoadedDocument     = document.querySelector(boxLoadedDocumentId);
                boxLoader.innerHTML         = '';
                boxLoadedDocument.innerHTML = '';
            }

            /* わかち書き文章の取得関数 */
            async function getWakachiSentence(sentence)
            {
                // バックエンド側のパス
                const pathServerMecab = "http://localhost:4000/";

                const response = await fetch(pathServerMecab, {
                    method: 'POST',
                    headers: {
                    'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: sentence }),
                });

                const  responseData    = await response.json();
                const  wakachiSentence = responseData.wakachiSentence;
                return wakachiSentence;
            }

            /* フォームデータの処理関数 */
            async function handleFormSubmit(event)
            {
                // リダイレクトを無効化
                event.preventDefault();

                const templateInvisibleUpload = document.querySelector('#template-invisible-upload');
                const fileContent = templateInvisibleUpload.files[0];

                if (!fileContent) {
                    alert('文書ファイルを選択してください。');
                    return;
                }

                try
                {
                    // サーバー側に送信するクエリ文書
                    const uploadDocument = {
                        name       : `1 ${fileContent.name}`,
                        normalText : '',
                        wakachiText: ''
                    };

                    const reader = new FileReader();
                    reader.readAsText(fileContent, 'UTF-8');

                    // ファイルのロードが完了するまで待機
                    const uploadedText = await new Promise((resolve, reject) => {
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = error => reject(error);
                    });

                    // クエリ文書の内容を設定
                    uploadDocument.normalText  = uploadedText;
                    uploadDocument.wakachiText = await getWakachiSentence(uploadedText);

                    // API 通信を開始
                    generateLoader();
                    generateLoadedDocument(fileContent.name, uploadedText)
                    await getKkData(uploadDocument);
                    generateDocumentForm();
                    clearLoader();
                }
                catch (error)
                {
                    console.error('Error reading file:', error);
                    return;
                }
            }

            document.addEventListener("DOMContentLoaded", () =>
            {
                generateDivider();
                generateDocumentForm();
            });
        </script>
<!-- ==== End Script ==== -->
    </body>
<!-- ==== End Body ==== -->
</html>
